io/nio
есть два типа потока, поток ввода и поток вывода.
обьект, в который мы что то пишем, это поток вывода
а поток ввода считывает данные
кратко можно свести все к input и output
есть основной объект, с которым мы взаимодействуем, от него идет инпут и аутпут, а у него уже есть какие то там классы
есть еще классы reader & writer

InputStream - класс, реализущий поток ввода, работает с байтами

читать с помощью inputsream неудобно, так как онв се делает с помощью байтов, для этого есть такой класс
reader, читает не байты, а чары.
Наш поток это труба, а эти трубы мы можем класть в цепочки данных, позволяет конструировать сложные потоки
чтения данных
баффераутпутстрим сокращает количество обращений к файлу, а значит оптимизирует и количество обращений
вместе с тем снижает нагрузку на систему очень сильно, выгодно с ними работать, ток вопрос, стоит ли пихать
это повсюду? спросить у Дэна!!
try (FileWriter fileWriter = new FileWriter("Users.txt");
             BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);
             InputStream inputStream = System.in;
             InputStreamReader inputStreamReader = new InputStreamReader(inputStream);
             BufferedReader bufferedReader = new BufferedReader(inputStreamReader)){
            String text;
            while(!"ESC".equals(text = bufferedReader.readLine())){
                bufferedWriter.write(text + "\n");
                bufferedWriter.flush();
            }
        } catch (IOException e){
            System.out.println(e);
        }
вот так можно базово сделать систему, пользователь ввел, а я сохранил в память, самая простая штука)
это называется логирование
=========================================================================================================
java nio
у nio блокирующий ввод/ввывод, блокируем доступ к нему, на время работы, не поддерживаем ссылки,
огромное количество исключений, которые мы должны обрабатывать
у java nio, есть буфероориентированность, есть неблокирущий поток на ввод и вывод, есть селекторы ( потом )
потокоориентированный воод/вывод - чтение или запись одного или нескольких байт будет идти поочередно,
невозможно произвольно двигаться по потоку вперед или назад
буфероориентированность - подход, на котором стоит java nio, данные сперва в буффер, потом только куда то еще
что дает нам гибкость
селектор одним потоком выполнения мониторит несколько каналов ввода
класс path - класс, который появился в java nio, пришедший на замену классу file из java nio,
предоставляет путь файловой системе на файл или папку ( каталог )
пути бывают двух типов, абсолютными и относительными.
абсолютный - полный путь
относительный - относительно некоторого другого пункта*
Path name =

















HW3 - реализация норм, нюансы - архитектура, осознание дальнейшего развития проекта






HW4
-------------------------------------
ЧИстая архитектура, если файл - это бд. от юзера к персонажу - 2 взаимодействия, можно ли сделать сразу за одно действие
сделать сразу регистрацию не на сущность юзера, а на сущность персонажа, можно вообще хранить персонажа ( к строке 88 )

!!! для ООП - представление обьекта как класса, если создал Юзера, живет там пользователь, персонаж, враг, кто угодно
он обязательно должен быть создан как отдельный класс со своими параметрами, полями и прочим, ни в коем случае не просто
запись в тхт


!! создалась domain, определение слова id!!
изучить record, UUID
консистентность - единообразие, в порядке.
Задание на вт - осознать обьектность ООП, предложить свою реализацию авторизации через обьект и сохранение юзера, как
вижу дальше - держать в голове. Продумать различные варианты
cериализация, десериализация - ?
hashmap изнутри разобрать, спрашивают почти всегда
ссылки в tg по нарастающей, в 3 ссылке хорошее описание, как идет работа мапы.
--------------------
продумать логику приложения дальше +-, первые несколько шагов должны быть, что вообще делаю, как оно это делает, для чего
оно должно это делать вообще, задай к каждой идее - а как? а зачем? а можно иначе? а дальше что?
любой обьект должен быть описан как обьект, это правило, это никак иначе не может быть, рано или поздно это вызовет
большие проблемы, поэтому от этого никак не уйти.
_______






!!!!!!!!!!!!!!!!! это относится к коллекциям, это их конец, осталось закрыть мап!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// доклад по коллекции:
// tree - коллекция, ее нужно подготовить.
какие они бывают, красночерное, бинарное, самобалансирубщиеся деервья
1. изучить вопрос, какие есть, что они делают, как они работают в памяти jvm, как работает при добавлении в красно черное
или в бинарное и тд, и каждую реализацию показать на примерах. (обьект, в красно черное, залогировать его движение)
1. сделать все в формате доклада, параллельно писать код.
например вот реализация tree, вот "что-то с ней",
сделать можно по готовому коду.
Например, 25 пробежать, просмотреть послушать, чтобы можно было внести правки в случае чего.
ТАК ЖЕ ОСТАЛОСЬ: очередь


ОТ КОЛЛЕКЦИЙ ПЕРЕХОДИМ К ИСКЛЮЧЕНИЯМ ( к след заданию )

MVC (применяется в спринге)
1. M - доменные обьекты приложения, основа приложения
2. V - представление этих обьектов, часть кода, отвечающая за вывод данных на пользователя
3. C - логика контроля движений. Принял из вне запрос, обрабатывет его, отправляет данные в 1. а после идет в 2.
посмотреть паттерн фасад -

Solid - изучить, принципы
S - single respons...


ЗАДАНИЕ ПО РАЗРАБОТКЕ
научиться и попробовать разделять логику на разные классы и разные уровни
необходимо: в классе maingame должен быть вызван всего лишь один метод.
класс main - всегда вход в приложение, никакой логики там, только ради какой то демонстрации, всегда.
научиться инжектить классы
разобраться как и почему происходит инжект без конструктора
изучить работу конструкторов
дефолтные конструкторы, как возникают самостоятельно, как правильнее самому создать или через конструктор
переобрать приложение. новое не писать, старое просто исправить в нормальный вид
1. точка входа - мейн
2. разделение логики
3. логика auth - куда ее привязать - authcharservice, инкапсуляция механизма персонажа,
4. view модель - изучить/понять ДОП - выводим данные, какие угодно, как их правильно выводить? подумать.













[5] - [1][2][3][4][5] 5 - ошибка
[] - [1][1][53]....[n] - динамический массив.



1. {ящик 1 : папка1, папка2, папка3, папка4} - 2. {ключ : значение}

